---
title:  "[컴퓨터공학] 가상 메모리의 이해"
excerpt: "2020-08-06 13:27:24"
last_modified_at:  2020-08-06 13:27:24 +0900
categories: computerScience
tags:
- computerScience
---

># 가상 메모리의 이해  

패스트캠퍼스 강의 보면서 정리하고 있습니다  


>### 가상 메모리(Virtual Memory System)  

- 실제 프로세스마다 충분한 메모리를 할당하기에 메모리 크기의 한계가 있음  
  - 예) 리눅스는 하나의 프로세스가 4GB  

- 폰노이만 구조 기반이므로 코드는 메모리에 반드시 있어야 함  

- 메모리가 실제 메모리보다 많아 보이게 하는 기술  
  - 실제 사용하는 메모리는 작다는 점에서 착안  
  - 프로세스 공간 분리로 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음  

- 가상 메모리 기본 아이디어  
  - 프로세는 가상 주소르 사용, 실제 해당 주소에서 데이터를 읽고 쓸 때 물리 주소로 바꿔준다  
  - virtual address : 프로세스가 참조하는 주소  
  - physical address : 실제 메모리 주소  

- MMU(Memory Management Unit)  
  - CPU에 코드 실행시 가상 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 빠르게 변환해주는 하드웨어 장치  


>### 페이징 시스템(Paging system)  

- 페이징 개념  
  - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리  
  - 하드웨어 지원이 필요  
    - 예) Intelx86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원  
  - 리눅스에서는 4KB로 페이징  
  - 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용  


>### 페이징 시스템 구조  

- page 또는 page frame : 고정된 크기의 block(4KB)  
- paging system  
  - 가상 주소 v = (p,d)  
    - p : 가상 메모리 페이지 번호  
    - d : p안에서 참조하는 위치 (오프셋)  

- 페이지 크기가 4KB 예
  - 가상 주소의 0비트에서 11비트가 변위를 나타냄  
  - 12비트 이상이 페이지 번호가 될 수 있음  


>### 페이지 테이블(page table)  

- 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표  


>### 페이징 시스템과 MMU  

- CPU는 가상 주소 접근시 MMU 하드웨어 장치를 통해 메모리 접근  
- 프로세스 생성시 페이지 테이블 정보 생성  
  - PCB등에서 해당 페이지 테이블 접근 가능하고 관련 정보는 물리 메모리에 적재  
  - 프로세스 구동시 해당 페이지 테이블 base 주소가 별도 레지스터에 저장 (CR3)  
  - CPU가 가상 주소 접근시 MMU가 페이지 테이블 base 주소를 접근해서 물리 주소를 가져옴  


>### 다중 단계 페이징 시스템  

- 페이징 정보의 단계를 나누어 생성 : 필요 없는 페이지는 생성하지 않아 공간 절약  


>### MMU와 TLB  

- TLB(Translation Lookaside Buffer) : 페이지 정보 캐쉬  
  - 최근에 변환된 물리 주소를 저장  

- MMU가 메모리에 여러번 접근하면 시간이 많이 소요 됨  


>### 페이징 시스템과 공유 메모리  

- 프로세스간 동일할 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)  
- 물리주소 데이터 변경시 물리 주소를 복사 할 수 있음 (copy-on-write)  


>### 요구 페이징 (Demand Paging 또는 Demanded Paging)  

- 프로세스 모든 데이터를 메모리로 적재하지 않고 실행 중 필요한 시점에서만 메모리로 적재  
  - 선행 페이징(Anticipatory Paging 또는 Prepaging)의 반대 개념  
  - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)  


>### 페이지 폴트 (Page Fault)  

- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트  
- 운영체제가 페이지 폴트가 일어나면 해당 페이지를 물리 메모리에 올림  

![페이지폴트](..\assets\images\post\cs\2020-08-08_cs_11_01.jpg)


- 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 이동  
- 새로운 페이지를 해당 물리 메모리로 이동  


>### 페이지 교체 알고리즘  

  - FIFO Page Replacement Algorithm

  - OPT(OPTimal) Page Replacement Algorithm (최적 페이지 교체 알고리즘)  
    - 앞으로 가장 오랫동안 사용하지 않을 페이지와 교체  
    - 일반 OS에서는 구현 불가  

  - LRU(Least Recently Used) Page Replacement Algorithm  
    - 가장 오래전에 사용된 페이지를 교체  
    - OPT 교체 알고리즘이 구현 불가, 과거 기록을 기반으로 시도  

  - LFU(Least Frequently Used) Page Replacement Algorithm  
    - 가장 적게 사용된 페이지와 교체  

  - NUR(Not Used Recently) page Replacement Algorithm  
    - LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법  
    - 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠 (R,M)  
      - (0,0),(0,1),(1,0),(1,1) 순으로 페이지 교체  
      - (0,0) : 읽히지도 수정도 안됨  


>### 스레싱 (Thrashing)  

- 반복적으로 페이지 폴트가 발생해서 과도하게 페이지 교체 작업이 일어나 실제로는 아무일도 하지 못하는 상황  


>### 세그멘테이션 (Segmentation) 기법  

  - 가상 메모리를 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할  
    - 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할  
    - 예) x86리얼모드  
      - CS(Code Segment), DS(Data Segment), SS(Stack Segment), ES(Extra Segment)로 나누어 메모리 접근  
  - 세그먼트 가상 주소  
    - v = (s,d)  
      - s : 세그먼트 번호  
      - d : 블록 내 세그먼트의 변위  


>### 문제점  

- 내부 단편화 (페이지 기법)  
  - 페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간 낭비  
- 외부 단편화 (세그먼테이션 기법)  
  - 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우 발생  
